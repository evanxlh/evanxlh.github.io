<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Xcode 制作 Framework &amp; XCFramework</title>
      <link href="/2020/06/14/make-frameworks-using-xcode/"/>
      <url>/2020/06/14/make-frameworks-using-xcode/</url>
      
        <content type="html"><![CDATA[<h1 id="使用-Xcode-制作-Framework-与-XCFramework"><a href="#使用-Xcode-制作-Framework-与-XCFramework" class="headerlink" title="使用 Xcode 制作 Framework 与 XCFramework"></a>使用 Xcode 制作 Framework 与 XCFramework</h1><p>最近公司有个项目外包，我就负责提供离在线语音识别 SDK 和数据埋点 SDK 封装，在制作 Framework 的过程中，遇到了很多问题。所以在这篇文章里我们会主要介绍下 如何制作 Frameworks ，以及如何解决遇到的一些问题。</p><h2 id="编译过程简述"><a href="#编译过程简述" class="headerlink" title="编译过程简述"></a>编译过程简述</h2><p>在制作 Framework 之前，我想简单阐述下编译器的工作原理，这有助于我们理解<a href="https://baike.baidu.com/item/静态库" target="_blank" rel="noopener">静态库</a>与<a href="">动态库</a>的制作。如果想了解编译器的详细设计，请点<a href="https://www.tutorialspoint.com/compiler_design/compiler_design_overview.htm">这里</a>。</p><p>我们都知道，计算机没法直接理解我们人类用高级语言写的程序，所以编译器可以帮助我们将高级语言写的程序转换成计算机能懂的二进制。下面我们结合一个简单的 C 程序来讲解下具体的编译过程。</p><h3 id="使用-GCC-编译源程序"><a href="#使用-GCC-编译源程序" class="headerlink" title="使用 GCC 编译源程序"></a>使用 GCC 编译源程序</h3><p>GCC（GNU Compiler Collection，GNU编译器套件）是由GNU开发的编程语言译器。GNU编译器套件包括C、C++、 Objective-C、 Fortran、Java、Ada和Go语言前端，也包括了这些语言的库（如libstdc++，libgcj等。） </p><p>GCC 的初衷是为 GNU 操作系统专门编写的一款编译器。GNU 系统是彻底的<a href="https://baike.baidu.com/item/自由软件/405190" target="_blank" rel="noopener">自由软件</a>，此处“自由”的含义是它尊重用户的自由。</p><h4 id="编写源程序"><a href="#编写源程序" class="headerlink" title="编写源程序"></a>编写源程序</h4><p>我们先编写一个简单的 C 程序，然后存储为 <code>hello.c</code> 源文件。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello, world\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="GCC-编译"><a href="#GCC-编译" class="headerlink" title="GCC 编译"></a>GCC 编译</h4><ul><li><p>编写好源程序后，在控制终端输入以下命令，gcc 自动会完成所有编译过程，最后输出可执行文件 <code>hello</code>。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br></pre></td></tr></table></figure></li><li><p>在终端运行可执行文件 <code>hello</code>，终端就会输出 <code>hello, world</code>。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./hello</span><br></pre></td></tr></table></figure></li></ul><p>我们可以看到，一个 gcc 命令就将源程序转变成了可执行文件，它使用源程序编译变得非常简单。但我们还是得深究下，gcc 究竟做了些啥事。接下来，我们就简单介绍下编译器的四个阶段：预处理、编译、汇编，以及链接。</p><p><img src="https://gitee.com/evanxlh/Resources/raw/master/blog/make-frameworks-xcode/compiler-phases.png" alt="编译过程"></p><h3 id="预处理阶段"><a href="#预处理阶段" class="headerlink" title="预处理阶段"></a>预处理阶段</h3><p><a href="https://www.tutorialspoint.com/cprogramming/c_preprocessors.htm" target="_blank" rel="noopener">CPP</a>，即 C Pre-Processor, 即 C 预处理器，是一个独立于C 编译器的小程序，预编译器并不理解 C 语言语法，它仅是在程序源文件被编译之前，实现文本替换的功能。</p><p>拿 <code>hello.c</code> 源程序为例，CPP 会根据 <strong><font color=green>#</font></strong> 开头的指令来修改源程序。比如 <code>hello.c</code> 中的第一行 <font color=green>#include <stdio.h></font> 就是告诉预处理器去把系统头文件 <font color=green>stdio.h</font> 内容读取出来，并直接插入到 <code>hello.c</code> 源程序中来，替换 <font color=green>#include <stdio.h></font>。</p><p>修改后的 C 程序一般另保存为 <strong><font color=green>.i</font></strong> 后缀的文本文件(本例为 <code>hello.i</code>)，输出的 <code>hello.i</code> 将用于下一个阶段。 </p><h3 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h3><p>接下来编译器 <a href="https://unix.stackexchange.com/questions/77779/relationship-between-cc1-and-gcc" target="_blank" rel="noopener">cc1</a> 将 <code>hello.i</code> 编译成汇编程序，并保存为 <strong><font color=green>.s</font></strong> 后缀的汇编语言文本文件(本例为 <code>hello.s</code>)。</p><p>编译成汇编语言程序有个好处，就是对于不同的编译器，不同的高级语言，都会编译输出一样的汇编程序。</p><p>例如，C 编译器 和 Fortran 编译器，编译后都会输出同样的汇编程序。</p><h3 id="汇编阶段"><a href="#汇编阶段" class="headerlink" title="汇编阶段"></a>汇编阶段</h3><h4 id="目标文件-Object-File"><a href="#目标文件-Object-File" class="headerlink" title="目标文件 (Object File)"></a>目标文件 (Object File)</h4><p>在介绍汇编阶段前，我们先了了解下目标文件(Object File), 它其实有 3 种形式：</p><ul><li><p>可重定位目标文件 (Relocatable Object File)</p><p>包含可与其它 <code>relocatable object file</code> 相结合的二进制代码和数据，由编译器和汇编器产生。</p></li></ul><ul><li><p>可执行文件 (Executable Object File)</p><p>包含可直接复制到内存并执行的二进制代码和数据，由链接器生成。</p></li></ul><ul><li><p>共享目标文件 (Shared Object File)</p><p>一种特殊的 <code>relocatable object file</code>，它可以被装载入内存，并且可以在装载或运行的时候动态地链接。</p><p>由编译器和汇编器产生。</p></li></ul><h4 id="汇编阶段的工作内容"><a href="#汇编阶段的工作内容" class="headerlink" title="汇编阶段的工作内容"></a>汇编阶段的工作内容</h4><p>汇编阶段的工作就是将汇编文本程序翻译成机器指令，输出目标文件。</p><p>汇编器 (as) 将汇编程序 <code>hello.s</code> 翻译成机器指令，然后包装成<a href="">可重定位目标程序(Relocatable Object Program)</a>，并将其结果保存在 <code>hello.o</code> 文件中。<code>hello.o</code> 为二进制文件。</p><h3 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h3><p>在我们的 hello 程序中，它调用了C 标准库中 <font color=green>printf</font> 方法，而 <font color=green>printf</font> 位于事先编译好的独立目标文件 <font color=green>printf.o</font> 中。所以为了能让 hello 程序运行起来，我们需要采取某种手段将 <font color=green>printf.o</font> 合并入  <font color=green>hello.o</font>。幸运的是，链接器(ld) 就是做这一工作。</p><p>经过链接器的合并操作后，输出 <font color=green>hello</font> 可执行文件。在终端命令行中输入 <code>./hello</code> 回车后， <font color=green>hello</font> 可执行文件被装载入内存(通过加载器Loader来完成)，并由系统执行，程序就跑起来了。</p><h2 id="Library"><a href="#Library" class="headerlink" title="Library"></a>Library</h2><p>我们在开发过程中，会把一些通用的函数制作成一个库，或者将一个功能模块制作成一个库 ，然后提供给 App 使用，可以达到共享复用的目的。</p><p>Library 可以理解成目标文件的集合，将相关的目标文件打包在一起，就成了一个 Library。我们按照 Library 是如何链接到 App 中的，可以把 Library 分成静态库和动态库。</p><h3 id="静态库-Static-Libraries"><a href="#静态库-Static-Libraries" class="headerlink" title="静态库(Static Libraries)"></a>静态库(Static Libraries)</h3><p>下图为 App 用到了静态库的情况。App 自身的代码被编译成目标文件后，通过静态链接器将App的目标文件与静态库合并，并生成的可执行文件。这样，App 自身代码生成的目标文件与静态库都被拷贝到可执行文件中，从而静态库也成为了 App 可执行文件的一部分。这样的库呢，我们称之为 静态库，也称为 <I>static archive libraries</I>, 或 <I>static linked shared libraries</I>.  </p><p><img src="https://gitee.com/evanxlh/Resources/raw/master/blog/make-frameworks-xcode/link-static-library.png" alt="Link Static Libraries"></p><h4 id="存在形式"><a href="#存在形式" class="headerlink" title="存在形式"></a>存在形式</h4><p>静态库主要以 <strong>.a</strong>， <strong>.lib</strong> 的形式存在，在苹果生态系统中，还可以是 <strong>.framework</strong> 或 <strong>.xcframework</strong> 。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><p>App 启动的时候就全部载入内存空间，所以在 App 运行过程中，需要使用依赖库的时候不需要额外从外部加载，速度快，但也增加了 App 的启动时间。</p></li><li><p>App 的可执行文件变大，占用内存也会相应增多。因为App依赖的所有静态库都会被静态链接器链接并拷贝到将要生成的 app 可执行文件中。</p></li><li>当静态库需要修改时，必须得重新编译和发布静态库，所以不便于维护。</li></ul><h3 id="动态库-Dynamic-Library"><a href="#动态库-Dynamic-Library" class="headerlink" title="动态库(Dynamic Library)"></a>动态库(Dynamic Library)</h3><p>动态库又 <em>dynamic shared libraries</em>, <em>shared objects</em>, or <em>dynamically linked libraries</em>。我们以 OS X 为例，当 App 启动时，操作系统内核会将 App 代码和数据载入新进程(<em>也就是操作系统为 App 创建的新进程</em>)的地址空间。与此同时呢，操作系统内核也会把<strong>动态加载器</strong>(<em>Dynamic Loader</em>) 载入进程，由<strong>动态加载器</strong>来完成加载 App 依赖的动态库。不过在启动阶段，<strong>动态加载器</strong>只会根据<strong>静态链接器</strong>中记录的 App 已链接的依赖库的名字，然后使用依赖库的 <code>install name</code> 来查找它们是否在文件系统中存在。如果不存在或不兼容，App 启动过程会中断。动态库被完全载入内存，是在代码里使用它的时候。所以相对静态库来说，使用动态库链接的 App 启动过程会更快。</p><p><img src="https://gitee.com/evanxlh/Resources/raw/master/blog/make-frameworks-xcode/link-dynamic-library.png" alt="Dynamic Link"></p><h4 id="存在形式-1"><a href="#存在形式-1" class="headerlink" title="存在形式"></a>存在形式</h4><p>动态库主要以 <strong>.dylib</strong>，<strong>.so</strong>，<strong>dll</strong> 的形式存在，在苹果生态系统中，还可以是 <strong>.framework</strong> 或 <strong>.xcframework</strong> 。</p><p>iOS App 的动态库存放在 <strong>.app</strong> <em>bundle</em> 下的 <em>Frameworks</em> 文件夹。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li><p>App 按需装载，可以加速 App 的启动。</p></li><li><p>动态库不会被拷贝到 App 的可执行文件中，所以可以动态按需加载。</p></li><li>动态库的维护和更新很方便，只要 APIs 不变，依赖动态库的 App 就不用重新编译 。因为动态库并不是 App 可执行文件的一部分，是独立的，可动态加载的。</li></ul><h2 id="Apple-FrameWorks"><a href="#Apple-FrameWorks" class="headerlink" title="Apple FrameWorks"></a>Apple FrameWorks</h2><h3 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h3><p>Framework 可以通俗的理解为封装了共享资源的具有层次结构的文件夹。共享资源可以是 nib文件、国际化字符串文件、头文件、库文件等等。它同时也是个 <code>Bundle</code>，里面的内容可以通过 <code>Bundle</code> 相关 API 来访问。Framework 可以是 <code>static framework</code> 或 <code>dynamic framework</code>。<font color=red> 在 iOS App 打包完成后，如果 Framework 包含了模拟器指令集(x86_64 或 i386)，那么用 Xcode 发布 App 的时候，会报 unsupported architectures 的错误，所以需要我们手动或脚本去移除。</font></p><h3 id="XCFramework"><a href="#XCFramework" class="headerlink" title="XCFramework"></a>XCFramework</h3><p>XCFramework 是由 Xcode 创建的一个可分发的二进制包，它包含了 <em>framework</em> 或 library 的一个或多个变体，因此可以在多个平台(iOS、macOS、tvOS、watchOS) 上使用，包括模拟器。<em>XCFramework</em> 可以是静态的，也可以是动态的。<code>xcframework</code> 的好处就是用 Xcode 发布的时候，Xcode 会自动选用正确的指令集 Frameworks，省去了手动移除动态库中的模拟器指令集的工作。<font color=red>不过值得注意的是，Xcode 11 才引入 XCFramework 。</font></p><h2 id="制作-Frameworks"><a href="#制作-Frameworks" class="headerlink" title="制作 Frameworks"></a>制作 Frameworks</h2><p>关于如何用 Xcode 一步一步创建 Framework 工程的话，我就不多说了，网上一大把教程，您也可以参考 <a href="http://appracatappra.com/2018/03/building-cross-platform-universal-frameworks-using-swift/" target="_blank" rel="noopener">Building Cross Platform Universal Frameworks</a>  或 <a href="https://github.com/TofPlay/SwiftCrossPlatformFramework" target="_blank" rel="noopener">Swift Cross Platform Framework</a>。我重点讲如何用脚本来制作各种类型的 <code>frameworks</code>。为什么要介绍脚本呢，网上不是很多脚本制作 frameworks 吗？ 刚开始我也是直接用网上的脚本，可总会有这样那样的问题，各种错误，所以决定在参考大神们文章的同时，自己重新整理下。</p><p>到这里，我假设您的 framework 代码都已经写好了，打包的 <strong>Aggregation Target</strong> 也创建好了。接下来，我将直接讲用脚本来制作 <em>frameworks</em> 。至于是制作 <em>static framework</em> 还是 <em>dynamic framework</em> 可以在 <code>framework target</code> 的 <code>Build Settings</code> 中的 <code>Mach-O Type</code> 选择 <em>framework</em> 的类型，一般选用 <code>Dynamic Library</code> 或者 <code>Static Library</code> 就行。</p><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>本文中使用的开发环境为：</p><ul><li>macOS Catalina 10.15.4</li><li>Xcode 11.5 </li></ul><h3 id="xcarchive-目录结构"><a href="#xcarchive-目录结构" class="headerlink" title=".xcarchive 目录结构"></a>.xcarchive 目录结构</h3><p>在制作 <em>universal framework</em> 与 <em>xcframework</em>，我们都会用到 <code>.xcarchive</code> 包，所以我们先来看下它的目录结构。</p><p><img src="https://gitee.com/evanxlh/Resources/raw/master/blog/make-frameworks-xcode/xcarchive-contents.png" alt="xcarchive contents" style="zoom:67%;" /></p><h3 id="制作-Universal-Framework-脚本"><a href="#制作-Universal-Framework-脚本" class="headerlink" title="制作 Universal Framework 脚本"></a>制作 Universal Framework 脚本</h3><p>你可以在这里直接获取<a href="https://github.com/evanxlh/MyDeveloperToolkit/blob/master/Shells/make_framework.sh" target="_blank" rel="noopener">制作 <em>universal framwork</em> 的完整脚本</a>。</p><h4 id="编译单个平台的函数"><a href="#编译单个平台的函数" class="headerlink" title="编译单个平台的函数"></a>编译单个平台的函数</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 制作完 framework 后，是否在 Finder 中打开</span></span><br><span class="line">REVEAL_FRAMEWORK_IN_FINDER=true </span><br><span class="line"><span class="meta">#</span><span class="bash"> Framework 的名字</span></span><br><span class="line">FREAMEWORK_NAME="$&#123;PROJECT_NAME&#125;" </span><br><span class="line"><span class="meta">#</span><span class="bash"> 制作好的 framework 会输出到这个文件夹下面</span></span><br><span class="line">FREAMEWORK_OUTPUT_DIR="$&#123;PROJECT_DIR&#125;/Distribution" </span><br><span class="line"><span class="meta">#</span><span class="bash"> Device Archive 生成的 .xcarchive 存放路径。在工程的根目录下生成 Build 文件夹。</span></span><br><span class="line">ARCHIVE_PATH_IOS_DEVICE="./Build/ios_device.xcarchive" </span><br><span class="line"><span class="meta">#</span><span class="bash"> Simulator Archive 生成的 .xcarchive 存放路径。</span></span><br><span class="line">ARCHIVE_PATH_IOS_SIMULATOR="./Build/ios_simulator.xcarchive"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们可以编译更多平台的 xcarchive</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ARCHIVE_PATH_MACOS=<span class="string">"./build/macos.xcarchive"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成单个平台的 .xcarchive. 接收4个参数， scheme, destination, archivePath，指令集.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> xcpretty 可以删除，这里用来使 Xcode 输出的日志更加人性化。</span></span><br><span class="line">function archiveOnePlatform &#123;</span><br><span class="line">echo "▸ Starts archiving the scheme: $&#123;1&#125; for destination: $&#123;2&#125;;\n▸ Archive path: $&#123;3&#125;"</span><br><span class="line"></span><br><span class="line">xcodebuild archive \</span><br><span class="line">-scheme "$&#123;1&#125;" \</span><br><span class="line">-destination "$&#123;2&#125;" \</span><br><span class="line">-archivePath "$&#123;3&#125;" \</span><br><span class="line">VALID_ARCHS="$&#123;4&#125;" \</span><br><span class="line">SKIP_INSTALL=NO \</span><br><span class="line">    BUILD_LIBRARY_FOR_DISTRIBUTION=YES | xcpretty</span><br><span class="line">    # BUILD_LIBRARY_FOR_DISTRIBUTION=YES</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo gem install -n /usr/<span class="built_in">local</span>/bin xcpretty</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> xcpretty makes xcode compile information much more readable.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编译所有平台的函数"><a href="#编译所有平台的函数" class="headerlink" title="编译所有平台的函数"></a>编译所有平台的函数</h4><p>以下方法可以编译并生成 <em>iOS device, simulator</em> 两个平台的 <code>.xcarchive</code>，此方法接收一个参数：<em>scheme</em>, 即 对应 <em>app target</em> 的 <em>scheme</em>。通常情况下，<em>scheme</em> 和 <em>framework name</em> 是相同的。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function archiveAllPlatforms &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> https://www.mokacoding.com/blog/xcodebuild-destination-options/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> PlatformDestination</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> iOSgeneric/platform=iOS</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> iOS Simulatorgeneric/platform=iOS Simulator</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> iPadOSgeneric/platform=iPadOS</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> iPadOS Simulatorgeneric/platform=iPadOS Simulator</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> macOSgeneric/platform=macOS</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tvOSgeneric/platform=tvOS</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> watchOSgeneric/platform=watchOS</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> watchOS Simulatorgeneric/platform=watchOS Simulator</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> carPlayOSgeneric/platform=carPlayOS</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> carPlayOS Simulatorgeneric/platform=carPlayOS Simulator</span></span><br><span class="line"></span><br><span class="line">SCHEME=$&#123;1&#125;</span><br><span class="line"></span><br><span class="line">archiveOnePlatform $SCHEME "generic/platform=iOS Simulator" $&#123;ARCHIVE_PATH_IOS_SIMULATOR&#125; "x86_64"</span><br><span class="line">  archiveOnePlatform $SCHEME "generic/platform=iOS" $&#123;ARCHIVE_PATH_IOS_DEVICE&#125; "armv7 arm64"</span><br><span class="line"><span class="meta">  #</span><span class="bash"> archiveOnePlatform <span class="variable">$SCHEME</span> <span class="string">"generic/platform=macOS"</span> <span class="variable">$&#123;ARCHIVE_PATH_MACOS&#125;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法执行完后，在本例中会得到以下 <em>Build</em> 文件夹内的内容：</p><p><img src="https://gitee.com/evanxlh/Resources/raw/master/blog/make-frameworks-xcode/xcarchives.png" alt="Generated xcarchives" style="zoom:67%;" /></p><h4 id="生成-Universal-Framework的函数"><a href="#生成-Universal-Framework的函数" class="headerlink" title="生成 Universal Framework的函数"></a>生成 Universal Framework的函数</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function makeUniversalFramework &#123;</span><br><span class="line"><span class="meta">#</span><span class="bash"> xcarchive 包中的 Frameworks 目录相对路径</span></span><br><span class="line">FRAMEWORK_RELATIVE_PATH="Products/Library/Frameworks"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来的三个路径分别是模拟器平台的framework路径，真机平台的framework路径，以及输出的universal framework路径</span></span><br><span class="line">SIMULATOR_FRAMEWORK="$&#123;ARCHIVE_PATH_IOS_SIMULATOR&#125;/$&#123;FRAMEWORK_RELATIVE_PATH&#125;/$&#123;FREAMEWORK_NAME&#125;.framework"</span><br><span class="line">DEVICE_FRAMEWORK="$&#123;ARCHIVE_PATH_IOS_DEVICE&#125;/$&#123;FRAMEWORK_RELATIVE_PATH&#125;/$&#123;FREAMEWORK_NAME&#125;.framework"</span><br><span class="line">OUTPUT_FRAMEWORK="$&#123;FREAMEWORK_OUTPUT_DIR&#125;/$&#123;FREAMEWORK_NAME&#125;.framework"</span><br><span class="line"></span><br><span class="line">mkdir -p "$&#123;OUTPUT_FRAMEWORK&#125;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Copy all the contents of iphoneos framework to output framework dir.</span></span><br><span class="line">cp -rf "$&#123;DEVICE_FRAMEWORK&#125;/." "$&#123;OUTPUT_FRAMEWORK&#125;"</span><br><span class="line"></span><br><span class="line">lipo "$&#123;SIMULATOR_FRAMEWORK&#125;/$&#123;FREAMEWORK_NAME&#125;" "$&#123;DEVICE_FRAMEWORK&#125;/$&#123;FREAMEWORK_NAME&#125;" \</span><br><span class="line">-create -output "$&#123;OUTPUT_FRAMEWORK&#125;/$&#123;FREAMEWORK_NAME&#125;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> For Swift framework, Swiftmodule needs to be copied <span class="keyword">in</span> the universal framework</span></span><br><span class="line">if [ -d "$&#123;SIMULATOR_FRAMEWORK&#125;/Modules/$&#123;FRAMEWORK_NAME&#125;.swiftmodule/" ]; then</span><br><span class="line">cp -f "$&#123;SIMULATOR_FRAMEWORK&#125;/Modules/$&#123;FRAMEWORK_NAME&#125;.swiftmodule/*" "$&#123;OUTPUT_FRAMEWORK&#125;/Modules/$&#123;FRAMEWORK_NAME&#125;.swiftmodule/" | echo</span><br><span class="line">fi</span><br><span class="line">if [ -d "$&#123;DEVICE_FRAMEWORK&#125;/Modules/$&#123;FRAMEWORK_NAME&#125;.swiftmodule/" ]; then</span><br><span class="line">cp -f "$&#123;DEVICE_FRAMEWORK&#125;/Modules/$&#123;FRAMEWORK_NAME&#125;.swiftmodule/*" "$&#123;OUTPUT_FRAMEWORK&#125;/Modules/$&#123;FRAMEWORK_NAME&#125;.swiftmodule/" | echo</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开始制作"><a href="#开始制作" class="headerlink" title="开始制作"></a>开始制作</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "#####################"</span><br><span class="line">echo "▸ Cleaning Framework output dir: $&#123;FREAMEWORK_OUTPUT_DIR&#125;"</span><br><span class="line">rm -rf "$FREAMEWORK_OUTPUT_DIR"</span><br><span class="line"></span><br><span class="line">echo "▸ Archive framework: $&#123;FREAMEWORK_NAME&#125;"</span><br><span class="line">archiveAllPlatforms "$FREAMEWORK_NAME"</span><br><span class="line"></span><br><span class="line">echo "▸ Make universal framework: $&#123;FREAMEWORK_NAME&#125;.framework"</span><br><span class="line">makeUniversalFramework</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Clean Build</span></span><br><span class="line">rm -rf "./Build"</span><br><span class="line"></span><br><span class="line">if [ $&#123;REVEAL_FRAMEWORK_IN_FINDER&#125; = true ]; then</span><br><span class="line">    open "$&#123;FREAMEWORK_OUTPUT_DIR&#125;/"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="去除动态库中的模拟器指令集"><a href="#去除动态库中的模拟器指令集" class="headerlink" title="去除动态库中的模拟器指令集"></a>去除动态库中的模拟器指令集</h4><p>正如之前提到的，App 打包过程中，需要将 App 依赖的动态库中的模拟器指令集去除，这里是<a href="https://github.com/evanxlh/MyDeveloperToolkit/blob/master/Shells/ios-remove-fat-framework-simulator-archs.sh" target="_blank" rel="noopener">完整的脚本</a>, 如何使用，请点 <a href="https://ikennd.ac/blog/2015/02/stripping-unwanted-architectures-from-dynamic-libraries-in-xcode/" target="_blank" rel="noopener">Stripping unwanted architectures from dynamic libraries</a>。在 <em>app target</em> 的 <strong>Build Phase</strong> 下新建 <em>Run Script</em>，并放到 <em>Embed Frameworks</em> 下面，然后将脚本复制进去就行。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">APP_PATH="$&#123;TARGET_BUILD_DIR&#125;/$&#123;WRAPPER_NAME&#125;"</span><br><span class="line"></span><br><span class="line">echo $APP_PATH</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> This script loops through the frameworks embedded <span class="keyword">in</span> the application and</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> removes unused architectures.</span></span><br><span class="line">find "$APP_PATH" -name '*.framework' -type d | while read -r FRAMEWORK</span><br><span class="line">do</span><br><span class="line">    FRAMEWORK_EXECUTABLE_NAME=$(defaults read "$FRAMEWORK/Info.plist" CFBundleExecutable)</span><br><span class="line">    FRAMEWORK_EXECUTABLE_PATH="$FRAMEWORK/$FRAMEWORK_EXECUTABLE_NAME"</span><br><span class="line">    echo "Executable is $FRAMEWORK_EXECUTABLE_PATH"</span><br><span class="line"></span><br><span class="line">    EXTRACTED_ARCHS=()</span><br><span class="line"></span><br><span class="line">    for ARCH in $ARCHS</span><br><span class="line">    do</span><br><span class="line">        echo "Extracting $ARCH from $FRAMEWORK_EXECUTABLE_NAME"</span><br><span class="line">        lipo -extract "$ARCH" "$FRAMEWORK_EXECUTABLE_PATH" -o "$FRAMEWORK_EXECUTABLE_PATH-$ARCH"</span><br><span class="line">        EXTRACTED_ARCHS+=("$FRAMEWORK_EXECUTABLE_PATH-$ARCH")</span><br><span class="line">    done</span><br><span class="line"></span><br><span class="line">    echo "Merging extracted architectures: $&#123;ARCHS&#125;"</span><br><span class="line">    lipo -o "$FRAMEWORK_EXECUTABLE_PATH-merged" -create "$&#123;EXTRACTED_ARCHS[@]&#125;"</span><br><span class="line">    rm "$&#123;EXTRACTED_ARCHS[@]&#125;"</span><br><span class="line"></span><br><span class="line">    echo "Replacing original executable with thinned version"</span><br><span class="line">    rm "$FRAMEWORK_EXECUTABLE_PATH"</span><br><span class="line">    mv "$FRAMEWORK_EXECUTABLE_PATH-merged" "$FRAMEWORK_EXECUTABLE_PATH"</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="制作-XCFramework-脚本"><a href="#制作-XCFramework-脚本" class="headerlink" title="制作 XCFramework 脚本"></a>制作 XCFramework 脚本</h3><h4 id="生成-Universal-Framework的函数-1"><a href="#生成-Universal-Framework的函数-1" class="headerlink" title="生成 Universal Framework的函数"></a>生成 Universal Framework的函数</h4><p>你可以在这里直接获取<a href="https://github.com/evanxlh/MyDeveloperToolkit/blob/master/Shells/make_xcframeworks.sh" target="_blank" rel="noopener">制作 <em>xcframwork</em> 的完整脚本</a>。编译单个平台和全部平台的函数跟制作 Framework 一样，所以这里直接列出制作 <em>xcframework</em> 的函数。<font color=red>制作 XCFramewrok 的时候，需要将 Build Settings 中的 <strong>Build Libraries for Distribution</strong> 设置为 YES。不过即使不设置，脚本也会将其设置为 YES。</font></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function makeXCFramework &#123;</span><br><span class="line"></span><br><span class="line">FRAMEWORK_RELATIVE_PATH="Products/Library/Frameworks"</span><br><span class="line">OUTPUT_DIR="$&#123;FREAMEWORK_OUTPUT_DIR&#125;/DynamicFramework"</span><br><span class="line"></span><br><span class="line">mkdir -p "$&#123;OUTPUT_DIR&#125;"</span><br><span class="line"></span><br><span class="line">xcodebuild -create-xcframework \</span><br><span class="line">-framework "$&#123;ARCHIVE_PATH_IOS_DEVICE&#125;/$&#123;FRAMEWORK_RELATIVE_PATH&#125;/$&#123;FREAMEWORK_NAME&#125;.framework" \</span><br><span class="line">-framework "$&#123;ARCHIVE_PATH_IOS_SIMULATOR&#125;/$&#123;FRAMEWORK_RELATIVE_PATH&#125;/$&#123;FREAMEWORK_NAME&#125;.framework" \</span><br><span class="line">-output "$&#123;OUTPUT_DIR&#125;/$&#123;FREAMEWORK_NAME&#125;.xcframework"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开始制作-1"><a href="#开始制作-1" class="headerlink" title="开始制作"></a>开始制作</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "#####################"</span><br><span class="line">echo "▸ Cleaning XCFramework output dir: $&#123;FREAMEWORK_OUTPUT_DIR&#125;"</span><br><span class="line">rm -rf $FREAMEWORK_OUTPUT_DIR</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">### Make XCFramework</span></span></span><br><span class="line"></span><br><span class="line">echo "▸ Archive framework: $&#123;FREAMEWORK_NAME&#125;"</span><br><span class="line">archiveAllPlatforms $FREAMEWORK_NAME</span><br><span class="line"></span><br><span class="line">echo "▸ Make framework: $&#123;FREAMEWORK_NAME&#125;.xcframework"</span><br><span class="line">makeXCFramework</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Clean Build</span></span><br><span class="line">rm -rf "./Build"</span><br><span class="line"></span><br><span class="line">if [ $&#123;REVEAL_XCFRAMEWORK_IN_FINDER&#125; = true ]; then</span><br><span class="line">    open "$&#123;FREAMEWORK_OUTPUT_DIR&#125;/"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>最后生成的 <em>xcframework</em> 长这个样子：</p><p><img src="https://gitee.com/evanxlh/Resources/raw/master/blog/make-frameworks-xcode/xcframe.png" alt="Generated xcarchives" style="zoom:67%;" /></p><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><ul><li><p>查看 framework 包含的指令集</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lipo -info /path/to/xxx.framework/xxx</span><br></pre></td></tr></table></figure></li><li><p>查看 dynamic framework 是否支持 bitcode</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">otool -arch armv7 -l /path/to/xxx.framework/xxx | grep __bundle</span><br></pre></td></tr></table></figure><p>如果包含 bitcode, 你会看到 <font color=red>sectname __bundle</font> 信息。如果不包含，Terminal 输出为空。</p></li><li><p>查看 static framework 是否支持 bitcode</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">otool -arch armv7 -l /path/to/xxx.framework/xxx | grep __bitcode</span><br></pre></td></tr></table></figure><p>如果包含 bitcode, 你会看到 <font color=red>sectname __bitcode</font> 信息。如果不包含，Terminal 输出为空。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>非常感谢以下文章的贡献者，使我对编译原理相关知识，以及对静态库、动态库、framework 有了更深刻的认识。</p><h3 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h3><p><a href="https://baike.baidu.com/item/gcc/17570?fr=aladdin" target="_blank" rel="noopener">GCC 百科</a></p><p><a href="http://gcc.gnu.org" target="_blank" rel="noopener">GCC, the GNU Compiler Collection</a></p><p><a href="https://www.tutorialspoint.com/cprogramming/c_preprocessors.htm" target="_blank" rel="noopener">C Pre-Processor</a></p><p><a href="https://www.tutorialspoint.com/compiler_design/compiler_design_overview.htm" target="_blank" rel="noopener">Compiler Design Overview</a></p><h3 id="Apple-Frameworks"><a href="#Apple-Frameworks" class="headerlink" title="Apple Frameworks"></a>Apple Frameworks</h3><p><a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html#//apple_ref/doc/uid/TP40001908-SW1" target="_blank" rel="noopener">Dynamic Library Programming Topics</a></p><p><a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/MachOTopics/1-Articles/loading_code.html#//apple_ref/doc/uid/TP40001830-SW1" target="_blank" rel="noopener">Mach-O Programming Topics</a></p><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/LoadingCode/LoadingCode.html#//apple_ref/doc/uid/10000052-SW1" target="_blank" rel="noopener">Code Loading Programming Topics</a></p><p><a href="https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Frameworks.html#//apple_ref/doc/uid/10000183-SW1" target="_blank" rel="noopener">Framework Programming Guide</a></p><p><a href="https://ikennd.ac/blog/2015/02/stripping-unwanted-architectures-from-dynamic-libraries-in-xcode/" target="_blank" rel="noopener">Stripping Unwanted Architectures From Dynamic Libraries In Xcode</a></p><p><a href="https://www.mokacoding.com/blog/xcodebuild-destination-options/" target="_blank" rel="noopener">XcodeBuild Destination</a></p><p><a href="https://xcodebuildsettings.com" target="_blank" rel="noopener">Xcode Build Settings</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
          <category> Xcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xcode Frameworks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS app 重签名及发布至 AppStore</title>
      <link href="/2020/05/28/ios-app-resigning/"/>
      <url>/2020/05/28/ios-app-resigning/</url>
      
        <content type="html"><![CDATA[<h1 id="iOS-app-重签名及发布至-AppStore"><a href="#iOS-app-重签名及发布至-AppStore" class="headerlink" title="iOS app 重签名及发布至 AppStore"></a>iOS app 重签名及发布至 AppStore</h1><p>由于公司有个项目请了外包团队来开发，但不提供源码，只提供 xcarchive 或 ipa 包，而做为公司又不可能将证书及私钥发给外包团队，让他们来打包。所以重签名就是绕不过的坎了，只能自己来做这一工作了。刚开始直接从网上找资料，直接用现成的脚本作些修改来进行重签名，可都会出现各种问题。无耐之下，只能翻阅苹果官网文档以及 <I>Troubleshooting</I>，最终完成重签名，并上传至 AppStore。现在将重签名过程重新整理下，记录下来方便以后查阅，也希望能帮助到有需要的同学们。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>代码签名(<I>Code Signing</I>)是操作系统应用的一种安全技术，用来证明 app 是你创建的。一旦 app 被签名后，操作系统就可以检测出 App 是否被意外或恶意地修改过，是否来自一个受信任的发布机构或组织，或个人。代码签名最基础、最核心部分就是数据的加密哈希函数和非对称加密，然后在此基础上，定义一些规则与策略，来完成代码签名。接下来，我们先来了解下签名相关的一些核心概念。</p><h4 id="加密哈希函数"><a href="#加密哈希函数" class="headerlink" title="加密哈希函数"></a>加密哈希函数</h4><p>加密哈希函数可以接收任意大小的数据，然后应用特定算法处理输入数据，并输出固定大小的哈希数据(如128 / 256 位等)。一些常见的哈希算法有 <I>SHA-1, SHA-2</I> 等等。在代码签名过程中，我们用它来生成代码数据的信息摘要(<I>message digest</I>, Apple 称它为 <I>seal</I>, 即封条，用来验证数据是否被更改)。</p><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p><a href="https://en.wikipedia.org/wiki/Public-key_cryptography" target="_blank" rel="noopener">非对称加密</a>(<I>public key cryptography, 或者 asymmetric cryptography</I>) 提供两组密钥：公钥和私钥。公钥可以公开并分享给他人，而私钥只能自己拥有。公称和私钥都可以用来加解密，但在一次加密解密过程中，需要配对使用。不管是用公钥加密，还是私钥加密，最后通过解密后，都能还原出明文，正如下图所示：<br><img src="https://gitee.com/evanxlh/Resources/raw/master/blog/ios-app-resigning/security-asymmetric.jpg" alt="Security Asymmetric">  </p><h4 id="信息摘要"><a href="#信息摘要" class="headerlink" title="信息摘要"></a>信息摘要</h4><p>信息摘要(<I>message digest</I>)是由代码签名软件创建的代码各个部分的校验和或哈希的集合，可以用来检测数据是否被更改。 拿写书信为例，写好的书信放入信封，然后进行密封。如果收信人发现密封损坏，他就会知道这封信肯定被打开过或被他人动过手脚。所以 Apple 也称它为 <I>seal</I>，意为密封或封条。通过私钥加密后，就成了代码签名中的加密信息摘要(<I>encrypted message digest</I>, 或者 <I>encrypted seal</I>)。  </p><h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>数字证书(<I>Digital Certificate</I>) 是用于验证数字证书 <I>持有者或发送者</I> 的身份的数据集合，来证明签名者公钥的真实性。比如  X.509 证书包含以下一些信息: </p><ul><li>结构信息: 版本，序列号，用于创建签名的消息摘要算法等</li><li>证书颁发机构的数字签名</li><li>有关证书持有者的信息: 名称，电子邮件地址，公司名称，所有者的公钥等</li><li>有效期: 证书在此期限之前或之后无效</li><li>证书扩展: 包含其他信息的属性，如证书的允许用途<br><img src="https://gitee.com/evanxlh/Resources/raw/master/blog/ios-app-resigning/anatomy-of-digital-certificate.png" alt="Digital Certificate" style="zoom:70%;" /><br>下图为 <I>Apple Worldwide Developer Relations Certification Authority</I> 证书中所包含的信息：<br><img src="https://gitee.com/evanxlh/Resources/raw/master/blog/ios-app-resigning/certificate-apple.png" alt="Apple Worldwide Developer Relations Certification Authority" style="zoom:67%;" /></li></ul><h4 id="数字身份"><a href="#数字身份" class="headerlink" title="数字身份"></a>数字身份</h4><p>数字身份(<I>Digital Identity</I>) 是公钥-私钥对以及对应的数字证书的组合。当我们向苹果申请到签名证书后，导入到 KeyChain Access 中，我们就获取到了数字身份，如下图所示:<br><img src="https://gitee.com/evanxlh/Resources/raw/master/blog/ios-app-resigning/digital-identity.jpg" alt="Digital Identity"></p><h4 id="证书颁发机构"><a href="#证书颁发机构" class="headerlink" title="证书颁发机构"></a>证书颁发机构</h4><p>证书颁发机构(Certification Authority) 是颁发数字证书的人员或组织，它确保数字证书没有被更改，并且表明颁发数字证书者的身份。如 Apple， 我们可以从 Apple 提供的工具来创建数字身份(<I>Digital Identity</I>)，并申请数字证书。</p><h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p>数字签名(<I>Digital Signatures</I>) 就是加密信息摘要及数字证书的组合，是一种使用非对称加密来保证数据完整性的方法。它可以用来验证数据签名者的身份，跟我们使用传统签名(用墨水在纸上写上自己的名字)方法一样，都是用来表明及验证身份的。但数字签名除了身份验证外，还能检查出数据是否被修改过。</p><h4 id="规范要求"><a href="#规范要求" class="headerlink" title="规范要求"></a>规范要求</h4><p><I>Code Requirements</I>，我就译成规范要求吧，是操作系统用来评估代码签名的规则。进行评估的系统根据其目标决定在评估时要应用哪些要求。比如 macos 的 <I>Gatekeeper</I> 有一个规则，即在首次允许启动应用程序之前，必须由Mac App Store或开发人员ID证书签名。再比如一个应用程序可以强制执行一个规范要求，即该应用程序使用的所有插件均应由 Apple 签名。有关规范的详细描述，可以查看<a href="https://developer.apple.com/library/archive/documentation/Security/Conceptual/CodeSigningGuide/AboutCS/AboutCS.html#//apple_ref/doc/uid/TP40005929-CH3-SW2" target="_blank" rel="noopener">苹果官方 Code Requirements</a>。</p><h2 id="数字签名原理"><a href="#数字签名原理" class="headerlink" title="数字签名原理"></a>数字签名原理</h2><h3 id="数字签名过程"><a href="#数字签名过程" class="headerlink" title="数字签名过程"></a>数字签名过程</h3><p>接下来，我们通过图例来阐述单个数据(这里指一个文件)的数字签名的过程： </p><ol><li>签名者使用加密哈希算法，生成信息摘要</li><li>使用私钥对信息摘要进行加密</li><li>将加密的信息摘要、有关签名者数字证书的信息，以及数据本身打包在一起，完成数字签名<br><img src="https://gitee.com/evanxlh/Resources/raw/master/blog/ios-app-resigning/code-signing.png" alt="Digital Signatures Process"> </li></ol><p><img src="https://gitee.com/evanxlh/Resources/raw/master/blog/ios-app-resigning/signing-doc.png" alt="a" style="zoom:60%;" /></p><h3 id="验证数字签名过程"><a href="#验证数字签名过程" class="headerlink" title="验证数字签名过程"></a>验证数字签名过程</h3><p>比如我们对一个文档进行了数据签名，那接收者如何去验证数字签名的正确性呢？下面我们结合图例来阐述下验证的过程： </p><ol><li>接收者从签名者的证书中获取签名者的公钥</li><li>使用公钥对加密信息摘要进行解密</li><li>接收者使用证书中指定的算法创建数据的新的信息摘要</li><li>将新的信息摘要与数字签名中传递的信息摘要的解密副本进行比较。 如果它们匹配，则接收到的数据肯定于签名者创建的原始数据相同。<br><img src="https://gitee.com/evanxlh/Resources/raw/master/blog/ios-app-resigning/verify-signature.png" alt="Verify digital signature" style="zoom:60%;" /></li></ol><h2 id="iOS-App-代码签名"><a href="#iOS-App-代码签名" class="headerlink" title="iOS App 代码签名"></a>iOS App 代码签名</h2><p>iOS 代码签名比之前提到的<a href="###数字签名过程">数字签名过程</a>会复杂一些，在签名过程中，还需要加入 <I>Provisioning Profile</I>，并且要对各种代码文件分别进行数字签名。</p><h3 id="需要对哪些文件签名"><a href="#需要对哪些文件签名" class="headerlink" title="需要对哪些文件签名"></a>需要对哪些文件签名</h3><p>iOS app 有三类文件需要签名: </p><ul><li><p><strong>内嵌代码 (<I>Nested code</I>)</strong><br>包括所有的打包在 App 内的 libraries, frameworks, helpers, tools， 以及 app 依赖的其它组件。<font color=red>注意静态库请不要内嵌，否则重签名后的 ipa 文件上传到 iTunes Connect 会报错。</font></p></li><li><p><strong>Mach-O 可执行文件 (<I>Mach-O executables</I>)</strong><br>签名软件会将签名信息直接写入可执行文件中。可执行文件包括 App 可执行文件 和 内嵌的 Framework 中的可执行文件。</p></li><li><p><strong>资源文件 (<I>Resources</I>)</strong><br>除了代码及可执行文件以外的文件都属于资源文件，都需要进行签名。每个资源文件签完名后，签名信息会被记录 <a href="###CodeResources">CodeResoures</a> 中，存放在 <code>_CodeSignature</code> 目录下。App 中可能会有多个 <code>_CodeSignature</code> 目录，因为 App 的 <I> main bundle</I> 中可能包含有内嵌 <I>framework bundle</I>, 或者其它的 <I>resource bundle</I>。</p></li></ul><h3 id="Entitlements"><a href="#Entitlements" class="headerlink" title="Entitlements"></a>Entitlements</h3><p>权限文件是一个特殊的 <em>plist</em> 文件，可以被认为是写入应用签名中的字符串，该字符串允许特定功能或使该应用选择特定服务。 操作系统在允许应用访问某些功能之前会检查这些字符串。 比如，在允许应用程序在运行时访问 Wi-Fi 信息之前，该应用程序必须具有 <em>Wi-Fi Info</em> 权利。 关于 <em>Entitlements</em> 更多的详细信息，<a href="https://developer.apple.com/library/archive/technotes/tn2318/_index.html#//apple_ref/doc/uid/DTS40013777-CH1-TNTAG33" target="_blank" rel="noopener">请点这里</a>。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">plist</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Apple//DTD PLIST 1.0//EN"</span> <span class="meta-string">"http://www.apple.com/DTDs/PropertyList-1.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>application-identifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>AA11BB22CC.com.company.appresignature.test<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>beta-reports-active<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.developer.networking.wifi-info<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.developer.team-identifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>AA11BB22CC<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>get-task-allow<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>keychain-access-groups<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>AA11BB22CC.*<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Provisioning-Profile"><a href="#Provisioning-Profile" class="headerlink" title="Provisioning Profile"></a>Provisioning Profile</h3><p><I>Provisioning Profile</I> 是一种系统配置文件，可让您在iOS设备或Mac上安装应用程序，用于在设备上启动一个或多个应用程序并使用某些服务。</p><p><I>Provisioning Profile</I> 文件包含签名证书、app bundle ID、Entitlements 信息，或者 deivce ids，不过 <I>Provisioning Profile</I> 可以分为 <I>Development / Distribution</I> 类型，而 <I>Distribution</I> 又分为 <I>AppStore / AdHoc / Inhouse</I> / Developer ID。每种类型的 <I>Provisioning Profile</I> 包含的信息都有些不一样，下图为 AppStore <I>Provisioning Profile</I> 包含的信息：</p><p><img src="https://gitee.com/evanxlh/Resources/raw/master/blog/ios-app-resigning/provisioning-profile.jpg" alt="AppStore Provisioning Profile" style="zoom:50%;" /></p><h3 id="CodeResources"><a href="#CodeResources" class="headerlink" title="CodeResources"></a>CodeResources</h3><p><I>CodeResources</I> 是一个特殊的 Plist 文件，<I>bundle</I> 中的每个资源文件的加密<a href="###信息摘要">信息摘要</a>都记录在这个 <I>Plist</I> 文件中。除了这些加密信息摘要以外，它还包括一些签名规则，可用于接收端进行签名验证。下图为 <I>CodeResources</I> 文件所包含的内容：</p><p><img src="https://gitee.com/evanxlh/Resources/raw/master/blog/ios-app-resigning/code-resource.png" alt="CodeResources" style="zoom:60%;" /></p><h3 id="App-签名"><a href="#App-签名" class="headerlink" title="App 签名"></a>App 签名</h3><p>大多数时候，Xcode可以帮我们自动完成所有的签名操作。但如果是手动来签名的话，我们需要使用 Apple 提供的  <code>codesign</code> 程序来签名。<code>codesign</code> 的签名规则如下：</p><ul><li><code>codesign</code> 可以直接给一个 <em>Bundle</em> 进行签名，这里的 <em>Bundle</em> 可以是 <em>app bundle (.app)</em> ，<em>framework bundle (.framework)</em>，<em>dynamic library (.dylib)</em> 等。</li><li>它采用递归策略对 <code>Bundle</code> 下的每个文件进行签名。<code>Bundle</code> 实际上就是一个文件夹。</li><li>可执行文件的加密信息摘要会被直接写入可执行文件的本身。这里说的可执行文件可以是 executable, Mach-O 文件类型，比如 app 的可执行文件，framework 中的可执行文件。</li><li>先从最底层 <code>Bundle</code> ，再签上层 <code>Bundle</code>。比如先签 <em>app bundle</em> 中的内嵌的每个 <em>framework bundle</em> ，然后签 <em>app bundle</em>。</li></ul><p><img src="https://gitee.com/evanxlh/Resources/raw/master/blog/ios-app-resigning/ios-app-code-signing.png" style="zoom:40%;" /></p><p>上图为 iOS app 代码签名的概览图，现在我们结合这张图来介绍 app 的签名流程。</p><ul><li><p>准备好签名要用到的所有资源：<em>ipa</em> 或 <em>xcarchive</em>，provisioning profile，签名证书。</p></li><li><p>将 App 中的各类代码文件(如库、可执行文件、脚本、资源文件，以及其他一些像代码的数据)按照<a href="###数字签名过程">数字签名过程</a>并结合签名规则进行签名，并把签名得到的 encryted seal 记录在 CodeResource 文件中。可执行文件 (Mach-O文件) 的 encryted seal 不会记录在 CodeResource， 而是直接写入可执行文件本身。</p></li><li><p>签完名后，重新打包 IPA。</p></li></ul><h2 id="App-重签名实战-★"><a href="#App-重签名实战-★" class="headerlink" title="App 重签名实战 ★"></a>App 重签名实战 <font color=red>★</font></h2><p>接下来，我们用苹果提供的命令行程序 <code>codesign</code> 来实现手动签名。如想了解 <code>codesign</code> 命令的具体用法，可以查看<a href="https://developer.apple.com/library/archive/documentation/Security/Conceptual/CodeSigningGuide/Procedures/Procedures.html#//apple_ref/doc/uid/TP40005929-CH4-SW2" target="_blank" rel="noopener">这篇文章</a>的 <I>Signing Code Manually</I> 小节。</p><h3 id="重签名环境"><a href="#重签名环境" class="headerlink" title="重签名环境"></a>重签名环境</h3><ul><li>MacOS: 10.15.4 </li><li>Xcode: version 11.5 </li></ul><h3 id="App-重签名参数配置文件"><a href="#App-重签名参数配置文件" class="headerlink" title="App 重签名参数配置文件"></a>App 重签名参数配置文件</h3><p>App 重签名需要提供一些参数，我们把这些参数都集中放到这个<a href="https://gitee.com/evanxlh/MyComputerToolkit/raw/master/Shells/ios-app-resigning/resigning-params-configuration.plist" target="_blank" rel="noopener">参数配置文件</a>中。以下为参数列表：</p><ul><li><p><strong>RootWorkingDirectory</strong> (必须)<br>Shell 脚本工作的根目录，<em>.ipa</em> 或 <em>.xcarchive</em>，provisioning profile 必需放在这个目录下。 <em>.ipa</em> 或者 <em>.xcarchive</em>，两者不能同时存在。</p></li><li><p><strong>SignIdentity</strong> (必须)<br>签名用的身份信息，可以在命令控制台终端输入 <code>security find-identity</code> ，列出 KeyChain Access 中的所有 <em>identities</em>，然后选择你要用的 <em>identity</em>.</p></li><li><p><strong>NewNameForIPA</strong> (可选)<br>重签名后输出的 <em>ipa</em> 文件名，不包括 <em>.ipa</em> 后缀。不提供则使用默认名。</p></li><li><p><strong>AppleID &amp; AppleIDPassword</strong>  (可选)<br>Apple ID 和 password 可选。如果提供，可以将重签名好的 <em>ipa</em> 直接上传到 iTunes Connect。</p></li></ul><p>所以在开始签名前，你的工作目录大概是这样，不过 脚本文件随便放哪都行：</p><div class="table-container"><table><thead><tr><th>重签名 ipa 的工作目录</th><th>重签名 xcarchive 的工作目录</th></tr></thead><tbody><tr><td><img src="https://gitee.com/evanxlh/Resources/raw/master/blog/ios-app-resigning/root-working-dir-ipa.png" alt="Working Directory" style="zoom:67%;" /></td><td><img src="https://gitee.com/evanxlh/Resources/raw/master/blog/ios-app-resigning/root-working-dir-xcarchive.png" alt="xcarchive working directory" style="zoom:67%;" /></td></tr></tbody></table></div><h3 id="Shell-脚本重签名"><a href="#Shell-脚本重签名" class="headerlink" title="Shell 脚本重签名"></a>Shell 脚本重签名</h3><p>Shell 脚本签名分为 10 个步骤，10 个步骤需要按照先后顺序执行， 你也可以在直接查看<a href="https://gitee.com/evanxlh/MyComputerToolkit/raw/master/Shells/ios-app-resigning/ios-app-resigning.sh" target="_blank" rel="noopener">完整的 shell 脚本</a>。<font color=red>脚本要求所有路径中不能有空格，所以请注意您 App 中的所有文件或文件夹名都不能带空格。</font></p><h4 id="1-读取重签名参数配置文件"><a href="#1-读取重签名参数配置文件" class="headerlink" title="1. 读取重签名参数配置文件"></a>1. 读取重签名参数配置文件</h4><p>执行脚本后，终端会提示你将重签名用的参数配置文件拖到控制台(这样就可以得到文件的绝对路径)。<a href="https://gitee.com/evanxlh/MyComputerToolkit/raw/master/Shells/ios-app-resigning/resigning-params-configuration.plist" target="_blank" rel="noopener">点我获取参数配置的样例文件</a>。</p><p><img src="https://gitee.com/evanxlh/Resources/raw/master/blog/ios-app-resigning/resigning-params.png" alt="Read resigning params" style="zoom:67%;" />   </p><h4 id="2-准备需要重签名的-app"><a href="#2-准备需要重签名的-app" class="headerlink" title="2. 准备需要重签名的 app"></a>2. 准备需要重签名的 app</h4><p>脚本支持对 <em>ipa, xcarchive</em> 两种包类型进行重签名。如果是 <em>ipa</em>，我们需要先将其解压；如果是 <em>xcarchive</em>，我们需要自己创建 <strong>IPA</strong> 的内容目录结构，并将 <em>xcarchive</em> 里面的 <em>app bundle</em> 拷贝到创建的 <em>Payload</em> 目录中去。如果 Xcode 工程开启 <code>EMBEDDED_CONTENT_CONTAINS_SWIFT</code>，我们还需要将 <em>SwiftSupport</em> 放入 <strong>IPA</strong>。 </p><p><img src="https://gitee.com/evanxlh/Resources/raw/master/blog/ios-app-resigning/embed-swift-standard-libraries.png" style="zoom:67%;" /> </p><p>最后 <strong>IPA</strong> 中的内容就如下图所示（SwiftSupport 需视实际情况来决定）：</p><p><img src="https://gitee.com/evanxlh/Resources/raw/master/blog/ios-app-resigning/ipa-contents.png" alt="App Contents" style="zoom:67%;" /> </p><h4 id="3-删除原有的-CodeSignature-目录"><a href="#3-删除原有的-CodeSignature-目录" class="headerlink" title="3. 删除原有的 _CodeSignature 目录"></a>3. 删除原有的 _CodeSignature 目录</h4><p>先递归查找 <em>app bundle</em> 中所有的 <code>_CodeSignature</code> 目录，然后将它们逐一删除。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">oldSignatures=`find $app_contents_root_path -name "_CodeSignature"`</span><br><span class="line"></span><br><span class="line">for signature in $oldSignatures; do</span><br><span class="line">  rm -rf $signature</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><h4 id="4-生成-entitlements-plist"><a href="#4-生成-entitlements-plist" class="headerlink" title="4. 生成 entitlements.plist"></a>4. 生成 entitlements.plist</h4><p><code>entitlements.plist</code> 在签名 <em>app bundle</em> 时需要使用，我们可以从提供的 <em>Provisioning Profile</em> 中提取出相关信息，并生成 <code>entitlements.plist</code>。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从 Provisioning Profile 中提取出来的 entitlements 信息存储路径</span></span><br><span class="line">entitlements_plist_path="$&#123;root_working_dir_path&#125;/entitlements.plist"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 *.mobileprovision 文件中的信息输出到一个临时plist</span></span><br><span class="line">security cms -D -i $new_profile_path &gt; tempProfile.plist</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从临时plist中提取出 entitlements 信息并写入 entitlements.plist</span></span><br><span class="line">/usr/libexec/PlistBuddy -x -c 'Print :Entitlements' tempProfile.plist &gt; $entitlements_plist_path</span><br></pre></td></tr></table></figure><h4 id="5-替换-Provisioning-Profile"><a href="#5-替换-Provisioning-Profile" class="headerlink" title="5. 替换 Provisioning Profile"></a>5. 替换 Provisioning Profile</h4><p>将新的 <em>Provisioning Profile</em> 拷贝到 <em>app bundle</em> 中，替换原有的 <em>Provisioning Profile</em>。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp $new_profile_path $app_profile_path</span><br></pre></td></tr></table></figure><h4 id="6-替换-Bundle-ID"><a href="#6-替换-Bundle-ID" class="headerlink" title="6. 替换 Bundle ID"></a>6. 替换 Bundle ID</h4><p>新的 <em>bundle id</em>，我们可以从之前生成的 <code>entitlements.plist</code> 中的 <em>application-identifier</em>  提取，但它包含了 <em>Team ID</em>, 需要将其移除。然后用新的 <em>bundle id</em> 替换 <em>app bundle</em> 中的 <code>Info.plist</code> 中的 <em>bundle id</em>。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> E6ABDGA.com.company.appresignature.test</span></span><br><span class="line">local app_identifier=`/usr/libexec/PlistBuddy -c "Print :application-identifier" $entitlements_plist_path`</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> https://stackoverflow.com/questions/10586153/split-string-into-an-array-in-bash</span></span><br><span class="line">IFS='.' read -r -a components &lt;&lt;&lt; "$&#123;app_identifier&#125;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Remove `E6ABDGA`: https://askubuntu.com/questions/435996/how-can-i-remove-an-entry-from<span class="_">-a</span>-list-in<span class="_">-a</span>-shells-script</span></span><br><span class="line">unset components[0]</span><br><span class="line">new_bundle_id=`joinStringComponents "." "$&#123;components[@]&#125;"`</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Replace the bundle id <span class="keyword">in</span> Info.plist with new bundle id.</span></span><br><span class="line">plutil -replace CFBundleIdentifier -string $new_bundle_id $app_infoplist_path</span><br></pre></td></tr></table></figure><h4 id="7-对内嵌-Frameworks-签名"><a href="#7-对内嵌-Frameworks-签名" class="headerlink" title="7. 对内嵌 Frameworks 签名"></a>7. 对内嵌 Frameworks 签名</h4><p>万事俱备只欠东风，我们现在正式开始签名。首先找出 <em>app bundle</em> 中的内嵌 Frameworks 和动态库，然后使用<a href="###数字身份">签名身份</a>逐一进行签名。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">local frameworks=`find $app_frameworks_path -name "*.framework" -o -name "*.dylib"`</span><br><span class="line"></span><br><span class="line">for framework in $frameworks; do</span><br><span class="line">  codesign -f -s "$&#123;sign_identity&#125;" $framework</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="8-对-App-Bundle-签名"><a href="#8-对-App-Bundle-签名" class="headerlink" title="8. 对 App Bundle 签名"></a>8. 对 App Bundle 签名</h4><p>对 <em>app bundle</em> 签名除了需要<a href="###数字身份">签名身份</a>， 还需要使用 <code>entitlements.plist</code>。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">codesign -f -s "$&#123;sign_identity&#125;" --entitlements "$&#123;entitlements_plist_path&#125;" $app_bundle_path</span><br></pre></td></tr></table></figure></p><h4 id="9-验证签名"><a href="#9-验证签名" class="headerlink" title="9. 验证签名"></a>9. 验证签名</h4><p>到目前为止，app 的签名工作已完成，现在我们来验证签名是否有效：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">https://developer.apple.com/library/archive/documentation/Security/Conceptual/CodeSigningGuide/Procedures/Procedures.html<span class="comment">#//apple_ref/doc/uid/TP40005929-CH4-SW9</span></span></span><br><span class="line">codesign --verify --deep --strict --verbose=2 $app_bundle_path</span><br></pre></td></tr></table></figure></p><p>如果验证失败，控制台会输出详细的错误。如果验证成功，控制台会输出:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/path/to/Test.app: valid on disk</span><br><span class="line">/path/to/Test.app: satisfies its Designated Requirement</span><br></pre></td></tr></table></figure></p><h4 id="10-制作已重签名的-IPA"><a href="#10-制作已重签名的-IPA" class="headerlink" title="10. 制作已重签名的 IPA"></a>10. 制作已重签名的 IPA</h4><p>签名验证也成功了，最后我们将所有的 App 内容重新压缩成 <em>.ipa</em> 文件，然后输出到指定目录(ResignedIPAs目录)。在压缩文件时，注意要忽略 <code>.DS_Store</code>。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">local root_content_names=`ls $app_contents_root_path`</span><br><span class="line">local contents_will_zipped=""</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出 app contents 根目录下的所有内容</span></span><br><span class="line">for name in $root_content_names; do</span><br><span class="line">  contents_will_zipped+="$name "</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">cd $app_contents_root_path</span><br><span class="line">zip -qr $new_ipa_name $contents_will_zipped -x "*.DS_Store"</span><br><span class="line">mv $new_ipa_name $ipa_output_directory</span><br></pre></td></tr></table></figure></p><h4 id="11-上传至-iTunes-Connect-可选"><a href="#11-上传至-iTunes-Connect-可选" class="headerlink" title="11. 上传至 iTunes Connect (可选)"></a>11. 上传至 iTunes Connect (可选)</h4><p>这一步为可选的，我们也可以将重签名的 <em>ipa</em> 直接通过命令行上传至 iTunes Connect。如果在重签名参数配置文件中有填写 <em>Apple ID</em> 和 <em>Apple ID Password</em>，Shell 脚本将执行这一步。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xcrun altool --upload-app -f $reigned_ipa_path -t iOS -u $apple_id -p $apple_id_password</span><br></pre></td></tr></table></figure></p><h3 id="常见错误解决"><a href="#常见错误解决" class="headerlink" title="常见错误解决"></a>常见错误解决</h3><p>常见的签名错误你都可以在这两个地方找到 <a href="https://developer.apple.com/library/archive/technotes/tn2318/_index.html" target="_blank" rel="noopener">Troubleshooting Failed Signature Verification</a> ，<a href="https://developer.apple.com/library/archive/technotes/tn2415/_index.html" target="_blank" rel="noopener">Entitlements Troubleshooting</a></p><h3 id="脚本及参数配置文件获取"><a href="#脚本及参数配置文件获取" class="headerlink" title="脚本及参数配置文件获取"></a>脚本及参数配置文件获取</h3><p>以下是完整的重签名 shell 脚本和参数配置文件：<br><a href="https://gitee.com/evanxlh/MyComputerToolkit/raw/master/Shells/ios-app-resigning/ios-app-resigning.sh" target="_blank" rel="noopener">ios-app-resigning.sh</a><br><a href="https://gitee.com/evanxlh/MyComputerToolkit/raw/master/Shells/ios-app-resigning/resigning-params-configuration.plist" target="_blank" rel="noopener">resigning-params-configuration.plist</a><br>写了这么久，总算完成了。可以好好休息下了！🍹</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://en.wikipedia.org/wiki/Public-key_cryptography" target="_blank" rel="noopener">Asymmetric Cryptography</a><br><a href="https://developer.apple.com/library/archive/documentation/Security/Conceptual/CodeSigningGuide/Introduction/Introduction.html" target="_blank" rel="noopener">Code Signing Guide</a><br><a href="https://developer.apple.com/library/archive/documentation/Security/Conceptual/cryptoservices/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011172-CH1-SW1" target="_blank" rel="noopener">Cryptographic Services Guide</a><br><a href="https://developer.apple.com/library/archive/documentation/Security/Conceptual/Security_Overview/Introduction/Introduction.html#//apple_ref/doc/uid/TP30000976-CH1-SW1" target="_blank" rel="noopener">Software Security Overview</a><br><a href="https://developer.apple.com/library/archive/technotes/tn2318/_index.html" target="_blank" rel="noopener">Technical Note TN2318: Troubleshooting Failed Signature Verification</a><br><a href="https://developer.apple.com/library/archive/technotes/tn2415/_index.html" target="_blank" rel="noopener">Technical Note TN2415: Entitlements Troubleshooting</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS开发 </category>
          
          <category> Xcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> App构建与发布 </tag>
            
        </tags>
      
    </entry>
    
    
    
    
  
  
</search>
